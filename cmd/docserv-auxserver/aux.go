// auxserver serves HTTP redirects and cookie handlers.
package main

import (
	"flag"
	"html/template"
	"log"
	"net/http"
	"os"
	"os/signal"
	"runtime/debug"
	"strings"
	"syscall"

	"github.com/thkukuk/rpm2docserv/pkg/auxserver"
	"github.com/thkukuk/rpm2docserv/pkg/bundled"
	"github.com/thkukuk/rpm2docserv/pkg/commontmpl"
	"github.com/thkukuk/rpm2docserv/pkg/redirect"
)

var (
	indexPaths = flag.String("index",
		"/srv/docserv/auxserver.idx",
		"List of comma separated path to auxserver index files generated by rpm2docserv")

	listenAddr = flag.String("listen",
		"localhost:2431",
		"host:port address to listen on")

	injectAssets = flag.String("assets",
		"",
		"If non-empty, a file system path to a directory containing assets to overwrite")
)

// use go build -ldflags "-X main.rpm2docservVersion=<version>" to set the version
var rpm2docservVersion = "HEAD"

func main() {
	flag.Parse()

	log.Printf("docserv auxserver loading index from %q", *indexPaths)

	if *injectAssets != "" {
		if err := bundled.Inject(*injectAssets); err != nil {
			log.Fatal(err)
		}
	}

	splittedPaths := strings.Split(*indexPaths, ",")
	idx, err := redirect.IndexFromProto(splittedPaths)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Loaded %d manpage entries, %d suites, %d languages from index %q",
		len(idx.Entries), len(idx.Suites), len(idx.Langs), *indexPaths)

	commonTmpls := commontmpl.MustParseCommonTmpls()
	notFoundTmpl := template.Must(commonTmpls.New("notfound").Parse(bundled.Asset("notfound.tmpl")))
	server := auxserver.NewServer(idx, notFoundTmpl, rpm2docservVersion)

	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGHUP)
	go func() {
		for _ = range c {
			log.Printf("SIGHUP received, trying to reload index")

			newidx, err := redirect.IndexFromProto(splittedPaths)
			if err != nil {
				log.Printf("Could not load new index from %q: %v", *indexPaths, err)
				continue
			}

			log.Printf("Loaded %d manpage entries, %d suites, %d languages from new index %q",
				len(newidx.Entries), len(newidx.Suites), len(newidx.Langs), *indexPaths)

			if err := server.SwapIndex(newidx); err != nil {
				log.Printf("Swapping index failed: %v", err)
				continue
			}

			log.Printf("Index swapped")
			// Force the garbage collector to return all unused memory to the
			// operating system. Even though, on Linux, unused memory can
			// apparently be reclaimed by the kernel, preemptively returning the
			// memory is less confusing for sysadmins who aren’t intimately
			// familiar with Go’s memory model.
			debug.FreeOSMemory()
		}
	}()

	basePath := commontmpl.BaseURLPath()
	mux := http.NewServeMux()
	mux.HandleFunc("/jump", server.HandleJump)
	mux.HandleFunc("/suggest", server.HandleSuggest)
	mux.HandleFunc("/", server.HandleRedirect)
	http.Handle("/", http.StripPrefix(basePath, mux))

	log.Printf("Starting HTTP listener on %q", *listenAddr)
	log.Fatal(http.ListenAndServe(*listenAddr, nil))
}
